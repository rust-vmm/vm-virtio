#![no_main]
use libfuzzer_sys::{arbitrary::Arbitrary, fuzz_target};
use rust_vmm_fuzz::{FuzzingDescriptor, VirtioQueueFunction};
use virtio_queue::{mock::MockSplitQueue, Descriptor};
use vm_memory::{GuestAddress, GuestMemoryMmap};

/// Input generated by the fuzzer for fuzzing virtio_queue
#[derive(Arbitrary, Debug)]
pub struct VirtioQueueInput {
    pub descriptors: Vec<FuzzingDescriptor>,
    pub functions: Vec<VirtioQueueFunction>,
}

fuzz_target!(|fuzz_input: VirtioQueueInput| {
    let m = &GuestMemoryMmap::<()>::from_ranges(&[(GuestAddress(0), 0x10000)]).unwrap();
    let vq = MockSplitQueue::new(m, fuzz_input.descriptors.len() as u16);
    let descriptors: Vec<Descriptor> = fuzz_input
        .descriptors
        .iter()
        .map(|desc| (*desc).into())
        .collect();

    // we return early because the coverage is not increasing, we expect the fuzzer to abandon the
    // paths that would generate invalid descriptors
    if vq.build_multiple_desc_chains(&descriptors).is_err() {
        return;
    }

    if let Ok(mut q) = vq.create_queue() {
        fuzz_input.functions.iter().for_each(|f| f.call(&mut q, m));
    }
});

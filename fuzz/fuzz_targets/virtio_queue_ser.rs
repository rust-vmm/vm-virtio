#![no_main]
use rust_vmm_fuzz::{FuzzingDescriptor, VirtioQueueFunction};
use virtio_queue::{Queue, QueueState, Descriptor, mock::MockSplitQueue};
use vm_memory::{GuestMemoryMmap, GuestAddress};
use libfuzzer_sys::{fuzz_target, arbitrary::Arbitrary};
use std::convert::{Into, TryFrom};

/// FuzzingQueueStateSer structure is similar to QueueStateSer, except it derives the Arbitrary
/// trait used for structure-aware fuzzing
#[derive(Arbitrary, Debug, Copy, Clone)]
pub struct FuzzingQueueState {
    pub max_size: u16,
    pub next_avail: u16,
    pub next_used: u16,
    pub event_idx_enabled: bool,
    pub size: u16,
    pub ready: bool,
    pub desc_table: u64,
    pub avail_ring: u64,
    pub used_ring: u64,
}

/// Input generated by the fuzzer for fuzzing QueueState
#[derive(Arbitrary, Debug)]
pub struct QueueStateInput {
    pub fuzzing_descriptors: Vec<FuzzingDescriptor>,
    pub fuzzing_queue_state: FuzzingQueueState,
    pub functions: Vec<VirtioQueueFunction>,
}

impl Into<QueueState> for FuzzingQueueState {
    fn into(self) -> QueueState {
        QueueState {
            max_size: self.max_size,
            next_avail: self.next_avail,
            next_used: self.next_used,
            event_idx_enabled: self.event_idx_enabled,
            size: self.size,
            ready: self.ready,
            desc_table: self.desc_table,
            avail_ring: self.avail_ring,
            used_ring: self.used_ring,
        }
    }
}

fuzz_target!(|queue_state_input: QueueStateInput| {
    let m = &GuestMemoryMmap::<()>::from_ranges(&[(GuestAddress(0), 0x10000)]).unwrap();
    let fuzzing_descriptors = queue_state_input.fuzzing_descriptors;
    let vq = MockSplitQueue::new(m, fuzzing_descriptors.len() as u16);
    let mut descriptors: Vec<Descriptor> = Vec::with_capacity(fuzzing_descriptors.len());
    for fuzzing_descriptor in fuzzing_descriptors {
        descriptors.push(fuzzing_descriptor.into());
    }
    // we return early because the coverage is not increasing, we expect the fuzzer to abandon the
    // paths that would generate invalid descriptors
    if vq.build_multiple_desc_chains(&descriptors).is_err() {
        return;
    }
    let q_state: QueueState = queue_state_input.fuzzing_queue_state.into();

    let mut q = match Queue::try_from(q_state) {
        Ok(q) => q,
        Err(_) => return,
    };

    for function in queue_state_input.functions {
        function.call(&mut q, m);
    }
});

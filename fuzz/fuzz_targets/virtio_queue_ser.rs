#![no_main]
use rust_vmm_fuzz::{FuzzingDescriptor, VirtioQueueFunction};
use virtio_queue::{Queue, QueueState, Descriptor, mock::MockSplitQueue};
use vm_memory::{GuestMemoryMmap, GuestAddress};
use libfuzzer_sys::{fuzz_target, arbitrary::Arbitrary};
use std::convert::{Into, TryFrom};

/// FuzzingQueueState structure is similar to QueueState, except it derives the Arbitrary
/// trait used for structure-aware fuzzing. The reason why we need a separate structure
/// that is duplicating the code is because Rust does not allow foreign trait (Arbitrary in this
/// case) implementations on foreign types.
#[derive(Arbitrary, Debug, Copy, Clone)]
pub struct FuzzingQueueState {
    pub max_size: u16,
    pub next_avail: u16,
    pub next_used: u16,
    pub event_idx_enabled: bool,
    pub size: u16,
    pub ready: bool,
    pub desc_table: u64,
    pub avail_ring: u64,
    pub used_ring: u64,
}

/// Input generated by the fuzzer for fuzzing QueueState
#[derive(Arbitrary, Debug)]
pub struct QueueStateInput {
    pub descriptors: Vec<FuzzingDescriptor>,
    pub queue_state: FuzzingQueueState,
    pub functions: Vec<VirtioQueueFunction>,
}

impl Into<QueueState> for FuzzingQueueState {
    fn into(self) -> QueueState {
        QueueState {
            max_size: self.max_size,
            next_avail: self.next_avail,
            next_used: self.next_used,
            event_idx_enabled: self.event_idx_enabled,
            size: self.size,
            ready: self.ready,
            desc_table: self.desc_table,
            avail_ring: self.avail_ring,
            used_ring: self.used_ring,
        }
    }
}

fuzz_target!(|fuzz_input: QueueStateInput| {
    let m = &GuestMemoryMmap::<()>::from_ranges(&[(GuestAddress(0), 0x10000)]).unwrap();
    let vq = MockSplitQueue::new(m, fuzz_input.descriptors.len() as u16);

    let descriptors: Vec<Descriptor> = fuzz_input.descriptors.iter().map(|desc| (*desc).into()).collect();
    // we return early because the coverage is not increasing, we expect the fuzzer to abandon the
    // paths that would generate invalid descriptors
    if vq.build_multiple_desc_chains(&descriptors).is_err() {
        return;
    }
    let q_state: QueueState = fuzz_input.queue_state.into();

    if let Ok(mut q) = Queue::try_from(q_state) {
        fuzz_input.functions.iter().for_each(|f| f.call(&mut q, m));
    }
});

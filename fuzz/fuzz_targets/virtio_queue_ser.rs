#![no_main]
use rust_vmm_fuzz::{FuzzingDescriptor, VirtioQueueFunction};
use virtio_queue::{QueueState, Descriptor, mock::MockSplitQueue};
use virtio_queue_ser::QueueStateSer;
use vm_memory::{GuestMemoryMmap, GuestAddress};
use libfuzzer_sys::{fuzz_target, arbitrary::Arbitrary};
use std::convert::Into;

/// FuzzingQueueStateSer structure is similar to QueueStateSer, except it derives the Arbitrary
/// trait used for structure-aware fuzzing
#[derive(Arbitrary, Debug, Copy, Clone)]
pub struct FuzzingQueueStateSer {
    pub max_size: u16,
    pub next_avail: u16,
    pub next_used: u16,
    pub event_idx_enabled: bool,
    pub num_added: u16,
    pub size: u16,
    pub ready: bool,
    pub desc_table: u64,
    pub avail_ring: u64,
    pub used_ring: u64,
}

/// Input generated by the fuzzer for fuzzing QueueState
#[derive(Arbitrary, Debug)]
pub struct QueueStateSerInput {
    pub fuzzing_descriptors: Vec<FuzzingDescriptor>,
    pub fuzzing_queue_state_ser: FuzzingQueueStateSer,
    pub functions: Vec<VirtioQueueFunction>,
}

impl Into<QueueStateSer> for FuzzingQueueStateSer {
    fn into(self) -> QueueStateSer {
        QueueStateSer {
            max_size: self.max_size,
            next_avail: self.next_avail,
            next_used: self.next_used,
            event_idx_enabled: self.event_idx_enabled,
            num_added: self.num_added,
            size: self.size,
            ready: self.ready,
            desc_table: self.desc_table,
            avail_ring: self.avail_ring,
            used_ring: self.used_ring,
        }
    }
}

fuzz_target!(|queue_state_ser_input: QueueStateSerInput| {
    let m = &GuestMemoryMmap::<()>::from_ranges(&[(GuestAddress(0), 0x10000)]).unwrap();
    let fuzzing_descriptors = queue_state_ser_input.fuzzing_descriptors;
    let vq = MockSplitQueue::new(m, fuzzing_descriptors.len() as u16);
    let mut descriptors: Vec<Descriptor> = Vec::with_capacity(fuzzing_descriptors.len());
    for fuzzing_descriptor in fuzzing_descriptors {
        descriptors.push(fuzzing_descriptor.into());
    }
    // we return early because the coverage is not increasing, we expect the fuzzer to abandon the
    // paths that would generate invalid descriptors
    if vq.build_multiple_desc_chains(&descriptors).is_err() {
        return;
    }
    let mut q = QueueState::from(&queue_state_ser_input.fuzzing_queue_state_ser.into());

    for function in queue_state_ser_input.functions {
        function.call(&mut q, m);
    }
});

#![no_main]
use libfuzzer_sys::fuzz_target;
use rust_vmm_fuzz::{FuzzingDescriptor, VirtioQueueFunction};
use serde::{Deserialize, Serialize};
use std::convert::{Into, TryFrom};
use virtio_queue::{mock::MockSplitQueue, Descriptor, Queue, QueueState};
use vm_memory::{GuestAddress, GuestMemoryMmap};

/// FuzzingQueueState structure is similar to QueueState, except it derives the Arbitrary
/// trait used for structure-aware fuzzing. The reason why we need a separate structure
/// that is duplicating the code is because Rust does not allow foreign trait (Arbitrary in this
/// case) implementations on foreign types.
#[derive(Serialize, Deserialize, Debug, Copy, Clone)]
pub struct FuzzingQueueState {
    pub max_size: u16,
    pub next_avail: u16,
    pub next_used: u16,
    pub event_idx_enabled: bool,
    pub size: u16,
    pub ready: bool,
    pub desc_table: u64,
    pub avail_ring: u64,
    pub used_ring: u64,
}

/// Input generated by the fuzzer for fuzzing QueueState
#[derive(Serialize, Deserialize, Debug)]
pub struct QueueStateInput {
    pub descriptors: Vec<FuzzingDescriptor>,
    pub queue_state: FuzzingQueueState,
    pub functions: Vec<VirtioQueueFunction>,
}

impl Into<QueueState> for FuzzingQueueState {
    fn into(self) -> QueueState {
        QueueState {
            max_size: self.max_size,
            next_avail: self.next_avail,
            next_used: self.next_used,
            event_idx_enabled: self.event_idx_enabled,
            size: self.size,
            ready: self.ready,
            desc_table: self.desc_table,
            avail_ring: self.avail_ring,
            used_ring: self.used_ring,
        }
    }
}

fuzz_target!(|data: &[u8]| {
    let fuzz_input = match bincode::deserialize::<QueueStateInput>(data) {
        Ok(input) => input,
        Err(_) => return,
    };

    let m = &GuestMemoryMmap::<()>::from_ranges(&[(GuestAddress(0), 0x10000)]).unwrap();
    let vq = MockSplitQueue::new(m, fuzz_input.descriptors.len() as u16);

    let descriptors: Vec<Descriptor> = fuzz_input
        .descriptors
        .iter()
        .map(|desc| (*desc).into())
        .collect();
    // we return early because the coverage is not increasing, we expect the fuzzer to abandon the
    // paths that would generate invalid descriptors
    if vq.build_multiple_desc_chains(&descriptors).is_err() {
        return;
    }
    let q_state: QueueState = fuzz_input.queue_state.into();

    if let Ok(mut q) = Queue::try_from(q_state) {
        fuzz_input.functions.iter().for_each(|f| f.call(&mut q, m));
    }
});

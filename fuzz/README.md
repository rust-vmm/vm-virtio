# Fuzzing

To implement fuzzing, we're first writing in the guest memory descriptor chains. This is a way to mimic what a Virtio
Driver implementation would do.

This project uses [structure-aware fuzzing](https://rust-fuzz.github.io/book/cargo-fuzz/structure-aware-fuzzing.html).
When using structure-aware fuzzing, the fuzzer can initialize a user provided structure with random data. This can be
achieved by deriving the `Arbitrary` trait on a user defined structure. One of the main components of the `virtio-queue`
implementation and a structure that we'd like to be able to initialize from random data is the `Descriptor`. As Rust
does not allow deriving foreign traits on foreign structure, we created a new structure called `FuzzingDescriptor`.
This structure contains the same fields as a regular descriptor, except that instead of using `Le64`, `Le32`, `Le16`,
it uses `u64`, `u32`, `u16`, because the former do not derive the `Arbitrary` trait, while the latter do.

## Fuzzing virtio_queue

For fuzzing the `QueueState` from the `virtio_queue` crate we defined an enum called `VirtioQueueFunction`,
which includes all the functions that we can call on the `QueueState` object. The reason why we use `QueueState` instead of `Queue`
is explained in this [issue](https://github.com/rust-vmm/vm-virtio/issues/143).

The process of fuzzing a `QueueState` object from the `virtio-queue` crate is shown in the picture below:

![Fuzzing virtio_queue](img/Fuzzing%20virtio-queue.png)

The fuzzer generates random input and, with this input, a Vec of `FuzzingDescriptor` and a Vec of
`VirtioQueueFunction` are initialized. The `FuzzingDescriptor`s are then transformed into regular
`Descriptor`s. A `MockSplitQueue` object is initialized. Using it and the Vector of `Descriptor`s created,
we create multiple `DescriptorChain`s (using the `build_multiple_desc_chains` defined in `mock.rs`) with which we can
initialize the `GuestMemory`. Then we use the initialized `GuestMemory` to create a `Queue` object. This `Queue` object
contains a `QueueState` object on which we call the functions generated by the fuzzer.

## Fuzzing virtio-queue-ser

While we initialized the queue presented in the previous section from a `MockSplitQueue`, we can also create a queue
starting from a state. For this purpose, we use `QueueState`, more specifically `QueueStateSer` (which is a
`QueueState` that has serialization capabilities).

The fuzzing process for `QueueState` can be seen below:

![Fuzzing QueueState](img/QueueState.png)

Besides a Vector of `FuzzingDescriptor`s, the fuzzer initializes a `FuzzingQueueStateSer` (identical to a `QueueStateSer`
structure) and a Vector of `VirtioQueueFunction`s.
The `GuestMemory` is initialized similarly to the process from `virtio_queue`.
We then create a `QueueStateSer` object from the `FuzzingQueueStateSer`, and using `QueueStateSer` we create a `QueueState`
object. We call the functions initialized by the fuzzer on the `QueueState` object, with the help of the `GuestMemory`.

## Fuzzing virtio_vsock

A `VsockPacket` can be created from a `DescriptorChain` or from raw pointers, and in this fuzzer we're focusing on the former.
The vsock device uses 2 queues: one for RX and one for TX, and the unit for operating with the
vsock device is a `VsockPacket`.
There are two different functions that we call on a `DescriptorChain` that can create a `VsockPacket` for the RX transmission
(by calling the `from_rx_virtq_chain` function), or a `VsockPacket` for the TX transmission (using `from_tx_virtq_chain`).

The fuzzing is done similarly to that for `virtio-queue`. The process can be seen in the picture below:

![Fuzzing vsock_rx](img/Vsock%20RX%20fuzzing.png)

Now the `VsockPacket` can only be created from a single descriptor chain, using either `from_rx_virtq_chain`, or
`from_tx_virtq_chain`. Once the `VsockPacket` is created, we're
calling all the functions from the public interface.

## Running the Fuzzing Session

Taking as an example fuzzing for the Virtio Queue, we are working with the following modules and
directories:
- `common/src/virtio_queue.rs` -> defines the structures used for fuzzing and a set of tests that
  when ran are generating a corpus for the fuzzer.
- `corpus/virtio_queue` -> the path of the corpus used when running the fuzzing session. This is
  also the path where we are writing the files generated by running the test cases.
- `fuzz_targets/virtio_queue.rs` -> the path for the Virtio Queue fuzz target.

### Generating Custom Fuzzing Input

To run the fuzzer with custom input, you first run the corresponding tests for each target. The
tests can be found in the local crate called `common`. Besides the tests, the `common` crate also
exports all the structures needed for running fuzzing. For simplicity, in the common crate we
define one module per fuzz target, and the modules have the same name as their corresponding fuzz
target. For example, the structures and other defines needed for fuzzing Virtio Queue are exported
as part of the `virtio_queue` Rust module (under the `common/src/virtio_queue.rs`). These defines
are used in the fuzz target definition under `fuzz_target/virtio_queue.rs`.

```bash
# The common package is not visible at the workspace level, we need to change directory.
cd fuzz/
# Run all tests in the virtio_queue module.
# This command will create the corpus/virtio_queue directory if it doesn't exist.
# And it will write one file per test case in the corpus directory.
cargo test --package common --lib virtio_queue
# Start the fuzzing session.
# The first positional argument after the run command represents the name of the fuzz target.
# The second positional argument after the run command is the path of the corpus.
cargo +nightly fuzz run --sanitizer address --jobs 12 virtio_queue corpus/virtio_queue/
```

## Running Fuzzing with Sanitizers

The available sanitizers are leak, thread, memory and address. You can only run with one sanitizer
at a time:
```bash
cargo +nightly fuzz run --sanitizer address virtio_queue
```

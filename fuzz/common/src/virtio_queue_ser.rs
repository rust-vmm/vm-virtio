use crate::{FuzzingDescriptor, VirtioQueueFunction};
use serde::{Deserialize, Serialize};
use virtio_queue::QueueState;

/// FuzzingQueueState structure is similar to QueueState, except it derives the
/// Serialize/Deserialize traits that we're using for structure-aware fuzzing.
/// The reason why we need a separate structure that is duplicating the code is
/// because Rust does not allow foreign trait (Arbitrary in this case)
/// implementations on foreign types.
#[derive(Serialize, Deserialize, Debug, Copy, Clone)]
pub struct FuzzingQueueState {
    pub max_size: u16,
    pub next_avail: u16,
    pub next_used: u16,
    pub event_idx_enabled: bool,
    pub size: u16,
    pub ready: bool,
    pub desc_table: u64,
    pub avail_ring: u64,
    pub used_ring: u64,
}

/// Input generated by the fuzzer for fuzzing QueueState
#[derive(Serialize, Deserialize, Debug)]
pub struct QueueStateInput {
    pub descriptors: Vec<FuzzingDescriptor>,
    pub queue_state: FuzzingQueueState,
    pub functions: Vec<VirtioQueueFunction>,
}

impl Into<QueueState> for FuzzingQueueState {
    fn into(self) -> QueueState {
        QueueState {
            max_size: self.max_size,
            next_avail: self.next_avail,
            next_used: self.next_used,
            event_idx_enabled: self.event_idx_enabled,
            size: self.size,
            ready: self.ready,
            desc_table: self.desc_table,
            avail_ring: self.avail_ring,
            used_ring: self.used_ring,
        }
    }
}

use crate::{FuzzingDescriptor, VirtioQueueFunction};
use serde::{Deserialize, Serialize};
use virtio_queue::QueueState;

/// FuzzingQueueState structure is similar to QueueState, except it derives the
/// Serialize/Deserialize traits that we're using for structure-aware fuzzing.
/// The reason why we need a separate structure that is duplicating the code is
/// because Rust does not allow foreign trait (Arbitrary in this case)
/// implementations on foreign types.
#[derive(Serialize, Deserialize, Debug, Copy, Clone, PartialEq)]
pub struct FuzzingQueueState {
    pub max_size: u16,
    pub next_avail: u16,
    pub next_used: u16,
    pub event_idx_enabled: bool,
    pub size: u16,
    pub ready: bool,
    pub desc_table: u64,
    pub avail_ring: u64,
    pub used_ring: u64,
}

/// Input generated by the fuzzer for fuzzing QueueState
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct QueueStateInput {
    pub descriptors: Vec<FuzzingDescriptor>,
    pub queue_state: FuzzingQueueState,
    pub functions: Vec<VirtioQueueFunction>,
}

impl Into<QueueState> for FuzzingQueueState {
    fn into(self) -> QueueState {
        QueueState {
            max_size: self.max_size,
            next_avail: self.next_avail,
            next_used: self.next_used,
            event_idx_enabled: self.event_idx_enabled,
            size: self.size,
            ready: self.ready,
            desc_table: self.desc_table,
            avail_ring: self.avail_ring,
            used_ring: self.used_ring,
        }
    }
}

impl Into<FuzzingQueueState> for QueueState {
    fn into(self) -> FuzzingQueueState {
        FuzzingQueueState {
            max_size: self.max_size,
            next_avail: self.next_avail,
            next_used: self.next_used,
            event_idx_enabled: self.event_idx_enabled,
            size: self.size,
            ready: self.ready,
            desc_table: self.desc_table,
            avail_ring: self.avail_ring,
            used_ring: self.used_ring,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::create_corpus_file;
    use std::io::Write;
    use virtio_queue::{Queue, QueueT};

    use super::super::virtio_queue::tests::create_basic_virtio_queue_ops;
    use super::*;
    use crate::virtio_queue::DEFAULT_QUEUE_SIZE;

    #[test]
    // Running this test will write to the fuzz input directory corresponding to the
    // virtio_queue_ser fuzz target the `basic_virtio_queue_ser` file, containing the
    // virtio queue descriptors, the virtio queue state and operations on the queues
    // as exemplified in the following test.
    fn write_basic_virtio_queue_ops() {
        let (mut out_file, path) = create_corpus_file("virtio_queue_ser", "basic_virtio_queue_ser");

        let virtq_fuzz_input = create_basic_virtio_queue_ops();
        let q_state = Queue::new(DEFAULT_QUEUE_SIZE).unwrap().state();
        let virtq_ser_fuzz_input = QueueStateInput {
            functions: virtq_fuzz_input.functions,
            queue_state: q_state.into(),
            descriptors: virtq_fuzz_input.descriptors,
        };

        out_file
            .write_all(
                bincode::serialize(&virtq_ser_fuzz_input)
                    .unwrap()
                    .as_slice(),
            )
            .unwrap();

        // Let's validate that we have in the file what we actually wrote.
        let written_input =
            bincode::deserialize::<QueueStateInput>(&std::fs::read(path).unwrap()).unwrap();
        assert_eq!(virtq_ser_fuzz_input, written_input);
    }
}
